# Autocomplete

> The `FluentAutocomplete` component is not yet fully compatible with the `EditForm` and `FluentEditForm` elements. Some functionalities, such as error messages, the requirement message or the validation messages are missing.

## Examples

### Default

<div style="display: flex; flex-direction: column; gap: 1rem;">
    <div>
        <label>Select a country</label>
        <div style="position: relative;">
            <input type="text" placeholder="Select countries" style="width: 250px; padding: 5px 8px; border-radius: 4px; border: 1px solid var(--neutral-stroke-rest);">
        </div>
    </div>
    <p><b>Selected</b>:</p>
    <div>
        <label><input type="checkbox"> Auto Height</label>
        <p>When the <code>MaxAutoHeight</code> attribute is set, the component adapts its height in relation to the selected elements.</p>
    </div>
</div>

```razor
@inject DataSource Data

<FluentAutocomplete TOption="Country"
                    AutoComplete="off"
                    Autofocus="true"
                    Label="Select a country"
                    Width="250px"
                    MaxAutoHeight="@(AutoHeight ? "200px" : null)"
                    Placeholder="Select countries"
                    OnOptionsSearch="@OnSearchAsync"
                    OptionDisabled="@(e => e.Code == "au")"
                    MaximumSelectedOptions="5"
                    OptionText="@(item => item.Name)"
                    @bind-SelectedOptions="@SelectedItems" />

<p>
    <b>Selected</b>: @(String.Join(" - ", SelectedItems.Select(i => i.Name)))
</p>
<p>
    <FluentSwitch @bind-Value="@AutoHeight" Label="Auto Height" /><br />
    When the <code>MaxAutoHeight</code> attribute is set, the component adapts its height in relation to the selected elements.
</p>
@code
{
    bool AutoHeight = false;
    IEnumerable<Country> SelectedItems = Array.Empty<Country>();

    private async Task OnSearchAsync(OptionsSearchEventArgs<Country> e)
    {
        var allCountries = await Data.GetCountriesAsync();
        e.Items = allCountries.Where(i => i.Name.StartsWith(e.Text, StringComparison.OrdinalIgnoreCase))
                              .OrderBy(i => i.Name);
    }
}
```

### Customized options

<div style="display: flex; flex-direction: column; gap: 1rem;">
    <div>
        <label>Select a person <svg width="20" height="20" fill="currentColor"><path d="M10 2a4 4 0 1 0 0 8 4 4 0 0 0 0-8Zm-6 12.5A5.5 5.5 0 0 1 9.5 9h1a5.5 5.5 0 0 1 5.5 5.5v.5h-11v-.5Z"/></svg></label>
        <div style="width: 100%; border: 1px solid var(--neutral-stroke-rest); padding: 5px; border-radius: 4px;">
            <!-- Selected options would go here -->
        </div>
    </div>
    <p><b>Selected</b>:</p>
</div>

```razor
@inject DataSource Data

<FluentAutocomplete Id="my-customized"
                    @ref="ContactList"
                    TOption="Person"
                    Width="100%"
                    Placeholder="search"
                    OnOptionsSearch="@OnSearch"
                    MaximumSelectedOptions="3"
                    KeepOpen="true"
                    OptionText="@(item => item.FirstName)"
                    OptionStyle="min-height: 40px;"
                    @bind-SelectedOptions="@SelectedItems">

    <LabelTemplate>        
        Select a person
        <FluentIcon Value="@(new Icons.Regular.Size20.Person())" Style="margin: 0 4px;" />
    </LabelTemplate>

    <SelectedOptionTemplate>
        <FluentPersona ImageSize="24px"
                            Image="@context.Picture"
                            Name="@($"{context.FirstName} {context.LastName}")"
                            Style="height: 26px; background: var(--neutral-fill-secondary-hover)"
                            DismissTitle="Remove"
                            Status="PresenceStatus.Available"
                            OnDismissClick="@(async () => await ContactList.RemoveSelectedItemAsync(context))" />
    </SelectedOptionTemplate>

    <OptionTemplate>
        <FluentPersona ImageSize="32px"
                            Image="@context.Picture"
                            Status="PresenceStatus.Available"
                            StatusSize="PresenceBadgeSize.Small"
                            Name="@($"{context.FirstName} {context.LastName}")" />
    </OptionTemplate>

    <MaximumSelectedOptionsMessage>
        The maximum number of selected items has been reached.
    </MaximumSelectedOptionsMessage>

    <HeaderContent>
        <FluentLabel Color="Color.Accent"
                     Style="padding: 8px; font-size: 11px; border-bottom: 1px solid var(--neutral-fill-stealth-hover);">
            Suggested contacts
        </FluentLabel>
    </HeaderContent>

    <FooterContent>
        @if (!context.Any())
        {
            <FluentLabel Style="font-size: 11px; text-align: center; width: 200px;">
                No results found
            </FluentLabel>
        }
    </FooterContent>
</FluentAutocomplete>

<p>
    <b>Selected</b>: @(String.Join(" - ", SelectedItems.Select(i => i.LastName)))
</p>

@code
{
    FluentAutocomplete<Person> ContactList = default!;
    IEnumerable<Person> SelectedItems = Array.Empty<Person>();

    private void OnSearch(OptionsSearchEventArgs<Person> e)
    {
        e.Items = Data.People.Where(i => i.LastName.StartsWith(e.Text, StringComparison.OrdinalIgnoreCase) ||
                                         i.FirstName.StartsWith(e.Text, StringComparison.OrdinalIgnoreCase))
                             .OrderBy(i => i.LastName);
    }
}
```

### Multiple == false

<div>
    <label>Select a country</label>
    <input type="text" placeholder="Select a country" style="width: 250px; padding: 5px 8px; border-radius: 4px; border: 1px solid var(--neutral-stroke-rest);">
    <p><b>Selected</b>:</p>
</div>

```razor
@inject DataSource Data

<FluentAutocomplete TOption="Country"
                    AutoComplete="off"
                    Label="Select a country"
                    Width="250px"
                    Placeholder="Select a country"
                    OnOptionsSearch="@OnSearchAsync"
                    OptionDisabled="@(e => e.Code == "au")"
                    Multiple=false
                    OptionText="@(item => item.Name)"
                    @bind-SelectedOption=SelectedItem />

<p>
    <b>Selected</b>: @(SelectedItem?.Name)
</p>

@code
{
    Country? SelectedItem = null;

    private async Task OnSearchAsync(OptionsSearchEventArgs<Country> e)
    {
        var allCountries = await Data.GetCountriesAsync();
        e.Items = allCountries.Where(i => i.Name.StartsWith(e.Text, StringComparison.OrdinalIgnoreCase))
                              .OrderBy(i => i.Name);
    }
}
```

### Many Items

This example shows how you can use `ImmediateDelay` to control the delay between the user input and the search for options. A value of 0 means no delay.

<div style="display: flex; flex-direction: column; gap: 10px;">
    <div>
        <label>Immediate Delay</label>
        <input type="number" value="0" style="padding: 5px 8px; border-radius: 4px; border: 1px solid var(--neutral-stroke-rest);">
    </div>
    <div>
        <label>Select Culture</label>
        <input type="text" placeholder="Select countries" style="width: 250px; padding: 5px 8px; border-radius: 4px; border: 1px solid var(--neutral-stroke-rest);">
    </div>
    <p><b>Selected</b>:</p>
</div>

```razor
@using System.Globalization
@inject DataSource Data

<FluentStack Orientation="Orientation.Vertical" VerticalGap="10">
    <FluentNumberField @bind-Value="_immediateDelay"
                       TValue="int"
                       Label="Immediate Delay"
                       Placeholder="Delay"
                       Min="0"
                       Max="2000"
                       Step="100" />
    
    <FluentAutocomplete TOption="CultureInfo"
                        ImmediateDelay="_immediateDelay"
                        AutoComplete="off"
                        Label="Select Culture"
                        Width="250px"
                        OnOptionsSearch="OnSearch"
                        Placeholder="Select countries"
                        MaximumOptionsSearch="int.MaxValue"
                        MaximumSelectedOptions="2"
                        Virtualize="true"
                        OptionText="@(item => $"{item.DisplayName} - {item.Name}")"
                        @bind-SelectedOptions="@SelectedCultures" />
</FluentStack>

<p>
    <b>Selected</b>: @(String.Join(" - ", SelectedCultures.Select(i => i.Name)))
</p>

@code
{
    private int _immediateDelay;

    IEnumerable<CultureInfo> SelectedCultures = Array.Empty<CultureInfo>();
    CultureInfo[] Cultures = CultureInfo.GetCultures(CultureTypes.AllCultures);

    private void OnSearch(OptionsSearchEventArgs<CultureInfo> e)
    {
        e.Items = Cultures.Where(culture =>
            culture.Name.Contains(e.Text, StringComparison.OrdinalIgnoreCase) ||
            culture.DisplayName.Contains(e.Text, StringComparison.OrdinalIgnoreCase));
    }
}
```

### Close via code

This example demonstrates how to close the dropdown in code.

```razor
@inject DataSource Data
@inject IDialogService DialogService

<FluentAutocomplete @ref=_autocomplete
                    TOption="Country"
                    AutoComplete="off"
                    Label="Select a country"
                    Width="250px"
                    MaxAutoHeight="@(AutoHeight ? "200px" : null)"
                    Placeholder="Select countries"
                    OnOptionsSearch="@OnSearchAsync"
                    OptionDisabled="@(e => e.Code == "au")"
                    MaximumSelectedOptions="5"
                    OptionText="@(item => item.Name)"
                    @bind-SelectedOptions="@SelectedItems">
    <FooterContent>
        <FluentStack Orientation="Orientation.Horizontal"
                     HorizontalAlignment="HorizontalAlignment.Right"
                     Style="padding: 3px;">
            <FluentButton OnClick="OpenDialog">
                Show Dialog
            </FluentButton>
        </FluentStack>
    </FooterContent>
</FluentAutocomplete>

<p>
    <b>Selected</b>: @(String.Join(" - ", SelectedItems.Select(i => i.Name)))
</p>

@code
{
    FluentAutocomplete<Country> _autocomplete = default!;
    bool AutoHeight = false;
    IEnumerable<Country> SelectedItems = Array.Empty<Country>();

    private async Task OnSearchAsync(OptionsSearchEventArgs<Country> e)
    {
        var allCountries = await Data.GetCountriesAsync();
        e.Items = allCountries.Where(i => i.Name.StartsWith(e.Text, StringComparison.OrdinalIgnoreCase))
                              .OrderBy(i => i.Name);
    }

    private async Task OpenDialog()
    {
        await _autocomplete.CloseDropdownAsync();
        await DialogService.ShowInfoAsync("You pressed a button to open a dialog and close the dropdown.");
    }
}
```

### Different object instances from search results

By default, the `FluentAutocomplete` component compares the search results by instance with its internal selected items. You can control that behavior by providing the `OptionComparer` parameter.

```razor
<FluentStack>
    <div>
        Without <code>OptionComparer</code>:
        <FluentAutocomplete TOption="SimplePerson"
                            Label="Users"
                            Class="w-100"
                            Placeholder="Name"
                            OnOptionsSearch="@OnSearchUserAsync"
                            OptionText="@(item => $"{item.Firstname} {item.Lastname}" )"
                            @bind-SelectedOptions="Users1" />
    </div>
    <div>
        With <code>OptionComparer</code>:
        <FluentAutocomplete TOption="SimplePerson"
                            Label="Users"
                            Class="w-100"
                            Placeholder="Name"
                            OnOptionsSearch="@OnSearchUserAsync"
                            OptionComparer="MyComparer.Instance"
                            OptionText="@(item => $"{item.Firstname} {item.Lastname}" )"
                            @bind-SelectedOptions="Users2" />
    </div> 
</FluentStack>

@code {
    public IEnumerable<SimplePerson> Users1 { get; set; } = [new SimplePerson { Firstname = "Marvin", Lastname = "Klein", Age = 28 }];
    public IEnumerable<SimplePerson> Users2 { get; set; } = [new SimplePerson { Firstname = "Marvin", Lastname = "Klein", Age = 28 }];

    private Task OnSearchUserAsync(OptionsSearchEventArgs<SimplePerson> e)
    {
        // Simulate new instances for every search.
        var results = new List<SimplePerson>
        {
            new SimplePerson { Firstname = "Alice", Lastname = "Wonder", Age = 31 },
            new SimplePerson { Firstname = "Marvin", Lastname = "Klein", Age = 28 },
            new SimplePerson { Firstname = "Vincent", Lastname = "Baaji", Age = 38 },
        };
        e.Items = results;
        return Task.CompletedTask;
    }

    public class MyComparer : IEqualityComparer<SimplePerson>
    {
        public static readonly MyComparer Instance = new();

        public bool Equals(SimplePerson? x, SimplePerson? y)
        {
            if (ReferenceEquals(x, y)) return true;
            if (x is null || y is null) return false;
            return x.Firstname == y.Firstname && x.Lastname == y.Lastname && x.Age == y.Age;
        }

        public int GetHashCode(SimplePerson obj) => HashCode.Combine(obj.Firstname, obj.Lastname, obj.Age);
    }
}
```

## Documentation

### FluentAutocomplete<TOption> Class

#### Parameters

| Parameter | Type | Default | Description |
| --- | --- | --- | --- |
| **Appearance** | `FluentInputAppearance` | `Outline` | Gets or sets the visual appearance. |
| **AutoComplete** | `string?` | | Specifies whether autocomplete should be 'on' or 'off'. |
| **ImmediateDelay** | `int` | `0` | Delay in milliseconds before raising the search event. |
| **Items** | `IEnumerable<TOption>?` | | The source of all items to display. |
| **KeepOpen** | `bool` | `False` | Whether the drop-down panel stays open after selecting an item. |
| **Label** | `string?` | | The text label for the input. |
| **MaximumSelectedOptions** | `int?` | | The maximum number of items that can be selected. |
| **Multiple** | `bool` | `True` | If true, the user can select multiple items. |
| **OptionComparer** | `IEqualityComparer<TOption>?`| | A comparer to determine if an option is already selected. |
| **OptionDisabled** | `Func<TOption, bool>?` | | A function to determine if an option is disabled. |
| **OptionTemplate** | `RenderFragment<TOption>?` | | A template for rendering items in the dropdown. |
| **OptionText** | `Func<TOption, string>?` | | A function to determine the text to display for each option. |
| **Placeholder** | `string?` | | The short hint displayed in the input before the user enters a value. |
| **SelectedOption** | `TOption?` | | The selected item when `Multiple` is false. |
| **SelectedOptions** | `IEnumerable<TOption>?`| | The selected items when `Multiple` is true. |
| **SelectedOptionTemplate**| `RenderFragment<TOption>`| | A template for rendering selected items. |
| **Virtualize** | `bool` | `False` | If true, the options list will be rendered with virtualization. |
| **Width** | `string?` | `100%` | The width of the component. |

#### EventCallbacks

| EventCallback | Type | Description |
| --- | --- | --- |
| **OnOptionsSearch** | `EventCallback<OptionsSearchEventArgs<TOption>>` | Filters the list of options based on user input. |
| **SelectedOptionChanged** | `EventCallback<TOption>` | Called when the selection changes (when `Multiple` is false). |
| **SelectedOptionsChanged**| `EventCallback<IEnumerable<TOption>>` | Called when the selection changes (when `Multiple` is true). |

#### Methods

| Method | Description |
| --- | --- |
| **CloseDropdownAsync()** | Closes the dropdown. |
| **InvokeOptionsSearchAsync()** | Programmatically performs the search operation. |
| **RemoveSelectedItemAsync(TOption item)** | Removes a selected item. |

### Placeholders and autofill

The `Placeholder` parameter is used to set the placeholder text for the input field. The placeholder value affects the autofill suggestion feature in browsers. To prevent autofill suggestions, avoid using common placeholder values like "name", "email", "address", etc. If you need to use these values, disable autofill in your browser settings.

### Accessibility

This component is compatible with accessibility rules. You can customize the messages read by screen readers for selected items, when no items are found, and when the maximum number of selected items is reached.