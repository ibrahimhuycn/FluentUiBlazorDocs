# Remote data

If you're using Blazor WebAssembly, it's very common to fetch data from a JSON API on a server. If you want to fetch only the data that's needed for the current page/viewport and apply any sorting or filtering rules on the server, you can use the `ItemsProvider` parameter.

You can also use `ItemsProvider` with Blazor Server if it needs to query an external endpoint, or in any other case where your requirements aren't covered by an `IQueryable`.

To do this, supply a callback matching the `GridItemsProvider<TGridItem>` delegate type. Your callback will be given a `GridItemsProviderRequest<TGridItem>` which specifies the start index, maximum row count, and sort order of data to return. As well as returning the matching items, you need to return a `totalItemCount` so that paging or virtualization can work.

## Example: Connecting to OpenFDA Food Enforcement database

This grid is using a 'sticky' header. The buttons in the last column disappear under the header when scrolling.

The second column has a custom `Style` and the 4th column has its `Tooltip` parameter set to `true`.

<div style="height: 434px; overflow:auto;" tabindex="-1">
    <!-- Placeholder for DataGrid -->
    <table style="width: 100%; border-collapse: collapse;">
        <thead style="position: sticky; top: 0; background-color: var(--neutral-layer-1);">
            <tr>
                <th>ID</th>
                <th style="color: #af5f00;">State</th>
                <th>City</th>
                <th>Company</th>
                <th>Status</th>
                <th>Actions</th>
            </tr>
        </thead>
        <tbody>
            <!-- Virtualized rows would be rendered here -->
        </tbody>
    </table>
</div>
<p>Total: <strong> results found</strong></p>

```razor
@using Microsoft.FluentUI.AspNetCore.Components
@inject HttpClient Http
@inject NavigationManager NavManager

<div style="height: 434px; overflow:auto;" tabindex="-1">
    <FluentDataGrid
                    ItemsProvider="foodRecallProvider"
                    OnRowDoubleClick="@(()=>DemoLogger.WriteLine("Row double clicked!"))"
                    Virtualize="true"
                    DisplayMode="DataGridDisplayMode.Table"
                    ItemSize="46"
                    GenerateHeader="GenerateHeaderOption.Sticky"
                    TGridItem="FoodRecall" >
        <PropertyColumn Title="ID" Property="@(c => c!.Event_Id)" />
        <PropertyColumn Property="@(c => c!.State)" Style="color: #af5f00 ;" />
        <PropertyColumn Property="@(c => c!.City)" />
        <PropertyColumn Title="Company" Property="@(c => c!.Recalling_Firm)" Tooltip="true"/>
        <PropertyColumn Property="@(c => c!.Status)" />
        <TemplateColumn Title="Actions" Align="@Align.End">
            <FluentButton aria-label="Edit item" IconEnd="@(new Icons.Regular.Size16.Edit())" OnClick="@(() => DemoLogger.WriteLine("Edit clicked"))" />
            <FluentButton aria-label="Delete item" IconEnd="@(new Icons.Regular.Size16.Delete())" OnClick="@(() => DemoLogger.WriteLine("Delete clicked"))" />
        </TemplateColumn>
    </FluentDataGrid>
</div>

<p>Total: <strong>@numResults results found</strong></p>

@code {
    GridItemsProvider<FoodRecall> foodRecallProvider = default!;
    int? numResults;

    protected override async Task OnInitializedAsync()
    {
        foodRecallProvider = async req =>
        {
            var url = NavManager.GetUriWithQueryParameters("https://api.fda.gov/food/enforcement.json", new Dictionary<string, object?>
            {
                { "skip", req.StartIndex },
                { "limit", req.Count },
            });

            var response = await Http.GetFromJsonAsync<FoodRecallQueryResult>(url, req.CancellationToken);

            return GridItemsProviderResult.From(
                items: response!.Results,
                totalItemCount: response!.Meta.Results.Total);
        };

        numResults = (await Http.GetFromJsonAsync<FoodRecallQueryResult>("https://api.fda.gov/food/enforcement.json"))!.Meta.Results.Total;
    }
}
```

## Remote data with `RefreshItems`

If the external endpoint controls filtering, paging, and sorting, you can use `Items` combined with `RefreshItems`.

The method defined in `RefreshItems` will be called once, and only once, if there is a change in the pagination or ordering.

Meanwhile, you can control the filtering with elements present on the page itself and force a call to `RefreshItems` with the `force` option in `RefreshDataAsync`.

```razor
@using Microsoft.FluentUI.AspNetCore.Components
@inject HttpClient Http
@inject NavigationManager NavManager

<FluentAccordion>
    <FluentAccordionItem Heading="Filter(s)" Expanded="true">
        <!-- Filter controls -->
    </FluentAccordionItem>
</FluentAccordion>
<br />
<div style="height: 484px; overflow:auto;" tabindex="-1">
    <FluentDataGrid @ref="dataGrid"
                    Items="foodRecallItems"
                    RefreshItems="RefreshItemsAsync"
                    Loading="loading"
                    Pagination="pagination">
        <!-- Columns -->
    </FluentDataGrid>
</div>
<FluentPaginator State="@pagination" />

@code {
    FluentDataGrid<FoodRecall> dataGrid = default!;
    IQueryable<FoodRecall> foodRecallItems = default!;
    bool loading = true;
    PaginationState pagination = new PaginationState { ItemsPerPage = 10 };
    string? _stateFilter = "NY";

    protected async Task RefreshItemsAsync(GridItemsProviderRequest<FoodRecall> req)
    {
        loading = true;
        // ... build filters and fetch data ...
        var response = await Http.GetFromJsonAsync<FoodRecallQueryResult>(url);
        foodRecallItems = response!.Results.AsQueryable();
        await pagination.SetTotalItemCountAsync(response!.Meta.Results.Total);
        loading = false;
    }
    
    public async Task DataGridRefreshDataAsync()
    {
        await dataGrid.RefreshDataAsync(true);
    }
}
```