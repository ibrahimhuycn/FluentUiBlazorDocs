# Dialog

As defined by the W3C:

> A dialog is a window overlaid on either the primary window or another dialog window. Windows under a modal dialog are inert. That is, users cannot interact with content outside an active dialog window. Inert content outside an active dialog is typically visually obscured or dimmed so it is difficult to discern, and in some implementations, attempts to interact with the inert content cause the dialog to close.
>
> Like non-modal dialogs, modal dialogs contain their tab sequence. That is, `Tab` and `Shift` + `Tab` do not move focus outside the dialog. However, unlike most non-modal dialogs, modal dialogs do not provide means for moving keyboard focus outside the dialog window without closing the dialog.

`<FluentDialog>` wraps the `<fluent-dialog>` element, a web component implementation of a dialog leveraging the Fluent UI design system. `<FluentDialog>` acts as a shell for the dialog content, which can be specified in a number of ways.

## DialogService

The `DialogService` is a service which is used to show different types of dialogs. It is registered as a scoped service, so it can be injected into pages/components that use it. For more information on the DialogService, see the [Dialog Service page](./).

## Dialog content

Normally, the dialog content is specified by a component which implements `IDialogContentComponent<T>`. This component is then passed to the `DialogService` to be shown. The `DialogService` will then render a `<FluentDialog>` with the component inside of it.

Alternatively, the dialog content can be specified manually by setting the `ChildContent` parameter of `<FluentDialog>`. This is useful if you want to show a simple dialog without having to create a component for it or if you do not want to use the `DialogService` for it. When using the `DialogService`, for displaying a regular dialog, the dialog will always be shown centered on the screen.

> **Note on WASM Trimming:** During the WASM DotNet Publication process, unused classes are automatically removed. If you only call a dialog component via a generic type parameter (e.g., `DialogService.ShowDialogAsync<SimpleDialog>(...)`), the `SimpleDialog` component might be removed. To prevent this, you can either configure the `PublishTrimmed` property in your project file or create a temporary instance (`var temp1 = new SimpleDialog();`) to ensure the compiler keeps a reference to it.

## Exchange data between dialog and calling component

There are two ways available to exchange data between the dialog and the component which shows it. The first is by capturing the returned `IDialogReference` from one of the `DialogService.Show...Async` methods and then using that reference to get the dialog's result (of type `DialogResult`). The second is by using an `EventCallback` parameter as part of the `DialogParameters`. Both ways are demonstrated in the samples below.

## Dialog provider

> **IMPORTANT!!**
> Dialogs are rendered by the `<FluentDialogProvider />` component. This component needs to be added to the main layout of your application/site. You typically do this in the `MainLayout.razor` file at the end of the `<main>` section.
>
> For the Dialogs to work properly, the `<FluentDialogProvider/>` needs interactivity! If you are using "per page" interactivity, make sure to add a `@rendermode` to either the provider itself or the component the provider is placed in.

```html
<main>
    <nav>
        ...
    </nav>
    <div class="content">
        <article id="article">
            @Body
        </article>
    </div>
    <FluentDialogProvider />
</main>
```

## Examples

These examples show how to use the `DialogService` to display a dialog. The content of the dialog is specified by a component which implements `IDialogContentComponent<T>`. Here, that is done in `SimpleDialog.razor`. The dialog is automatically styled and centered. Interaction with the parent dialog can be made by injecting `FluentDialog` as a Cascading Parameter.

### DialogService with IDialogReference

This example shows how to use `async` methods to display a dialog and get the result back from it.

#### Razor

```razor
@inject IDialogService DialogService

<div>
    <p>When 'Modal' is checked, the dialog can be dismissed by clicking outside of it. When unchecked, it can be dismissed only by the 'ESC' key.</p>
    <p>When 'Trap focus' is checked, only the elements within the dialog will receive focus.</p>
    <FluentCheckbox Name="modal" @bind-Value="_modal">Modal</FluentCheckbox>
    <FluentCheckbox Name="trap" @bind-Value="_trapFocus">Trap focus</FluentCheckbox>
</div>
<div style="margin-top: 1rem;">
    <FluentButton @onclick="@OpenDialogAsync" Appearance="Appearance.Accent">Open Dialog</FluentButton>
</div>

@code {
    private bool _trapFocus = true;
    private bool _modal = true;
    SimplePerson simplePerson = new() { Firstname = "Dan", Lastname = "Sanderson", Age = 42 };

    private async Task OpenDialogAsync()
    {
        DialogParameters parameters = new()
        {
            Title = $"Hello {simplePerson.Firstname}",
            PrimaryAction = "Yes",
            PrimaryActionEnabled = false,
            SecondaryAction = "No",
            Width = "500px",
            TrapFocus = _trapFocus,
            Modal = _modal,
            PreventScroll = true 
        };

        IDialogReference dialog = await DialogService.ShowDialogAsync<SimpleDialog>(simplePerson, parameters);
        DialogResult? result = await dialog.Result;
        
        if (result.Data is not null)
        {
            var person = result.Data as SimplePerson;
            DemoLogger.WriteLine($"Dialog closed by {person?.Firstname} {person?.Lastname} ({person?.Age}) - Canceled: {result.Cancelled}");
        }
        else
        {
            DemoLogger.WriteLine($"Dialog closed - Canceled: {result.Cancelled}");
        }
    }
}
```

#### SimpleDialog.razor

```razor
@implements IDialogContentComponent<SimplePerson>

<p>Your lastname is @Content.Lastname and you are @Content.Age years young.</p>

<FluentTextField @bind-Value="@Content.Firstname">Your firstname:</FluentTextField>
<FluentTextField @bind-Value="@Content.Lastname">Your lastname:</FluentTextField>
<FluentNumberField @bind-Value="@Content.Age">Your age:</FluentNumberField>

@if (Dialog != null)
{
    <FluentStack Orientation="Orientation.Vertical" Style="border: 1px solid red; padding: 10px">
        <span>This section is visible only when component is hosted inside a Dialog</span>
        <FluentButton OnClick="@(() => ToggleDialogPrimaryActionButton(true))">Enable Dialog Primary Action</FluentButton>
        <FluentButton OnClick="@(() => ToggleDialogPrimaryActionButton(false))">Disable Dialog Primary Action</FluentButton>
    </FluentStack>
}

@code {
    [Parameter]
    public SimplePerson Content { get; set; } = default!;

    [CascadingParameter]
    public FluentDialog? Dialog { get; set; }

    private void ToggleDialogPrimaryActionButton(bool enable)
    {
        Dialog!.TogglePrimaryActionButton(enable);
    }
}
```

### Customized Dialog

This example shows how to customize a dialog by specifying a header, footer, and body using `FluentDialogHeader`, `FluentDialogFooter`, and `FluentDialogBody`.

#### SimpleCustomizedDialog.razor

```razor
@implements IDialogContentComponent<DialogCustomizableExample.NameAndAge>

<FluentDialogHeader ShowDismiss="true">
    <FluentStack VerticalAlignment="VerticalAlignment.Center">
        <FluentIcon Value="@(new Icons.Regular.Size24.WindowApps())" />
        <FluentLabel Typo="Typography.PaneHeader">@Dialog.Instance.Parameters.Title</FluentLabel>
    </FluentStack>
</FluentDialogHeader>

<FluentDialogFooter>
    <FluentButton Appearance="Appearance.Accent" OnClick="@SaveAsync">Save</FluentButton>
    <FluentButton Appearance="Appearance.Neutral" OnClick="@CancelAsync">Cancel</FluentButton>
</FluentDialogFooter>

<FluentDialogBody>
    <FluentTextField @bind-Value="@Content.Name">Name:</FluentTextField>
    <FluentNumberField @bind-Value="@Content.Age">Age:</FluentNumberField>
</FluentDialogBody>

@code {
    [Parameter]
    public DialogCustomizableExample.NameAndAge Content { get; set; } = default!;

    [CascadingParameter]
    public FluentDialog Dialog { get; set; } = default!;

    private async Task SaveAsync() => await Dialog.CloseAsync(Content);
    private async Task CancelAsync() => await Dialog.CancelAsync();
}
```

### Dialog without using DialogService

This example shows a simple dialog created by specifying its content manually. Because of this, the dialog is not automatically styled. A CSS file has been added to set the width, height, and padding.

#### Razor

```razor
<div>
    <!-- Checkboxes for modal, trap focus, prevent scroll -->
</div>
<div>
    <FluentDialog @ref="_myFluentDialog" @bind-Hidden="@Hidden" aria-label="Simple dialog" Modal=@_modal TrapFocus=@_trapFocus PreventScroll=@_preventScroll @ondialogdismiss=OnDismiss>
        <FluentDialogHeader Visible="false" />
        <h2>Just a simple dialog</h2>
        <p>The 'Close dialog' button is automatically focused.</p>
        <FluentButton Appearance="Appearance.Accent" Autofocus="true" @onclick="OnClose">Close dialog</FluentButton>
        <FluentButton>Another button</FluentButton>
    </FluentDialog>
</div>
<p>Status: @_status</p>
<FluentButton Appearance=Appearance.Accent @onclick="OnOpen">Open dialog</FluentButton>

@code {
    private FluentDialog? _myFluentDialog;
    private bool _trapFocus = true;
    private bool _modal = true;
    private bool _preventScroll = true;
    private string? _status;
    private bool Hidden { get; set; } = true;

    private void OnOpen()
    {
        _status = "Dialog opened with button click";
        _myFluentDialog!.Show();
    }
    private void OnClose()
    {
        _status = $"Dialog dismissed with reason: Close button clicked";
        _myFluentDialog!.Hide();
    }
    private void OnDismiss(DialogEventArgs args)
    {
        if (args.Reason == "dismiss")
        {
            _status = $"Dialog dismissed with reason: Dismissed";
            _myFluentDialog!.Hide();
        }
    }
}
```

#### CSS

```css
::deep > fluent-dialog::part(control) {
    --dialog-width: 300px;
    --dialog-height: 350px;
    padding: 2rem!important;
}
```

## Documentation

### FluentDialog Class

#### Parameters
| Parameter | Type | Default | Description |
|---|---|---|---|
| **AriaLabel** | `string?` | | The label surfaced to assistive technologies. |
| **ChildContent** | `RenderFragment?` | | Content used when not calling `DialogService`. |
| **Hidden** | `bool` | `False` | Whether the dialog is hidden. |
| **Modal** | `bool?` | | If true, the user interaction is limited to the dialog. |
| **PreventScroll** | `bool` | `True` | Prevents scrolling outside of the dialog. |
| **TrapFocus** | `bool?` | | If true, the dialog should trap focus. |

#### EventCallbacks
| EventCallback | Type | Description |
|---|---|---|
| **HiddenChanged** | `EventCallback<bool>` | Invoked when the `Hidden` property changes. |
| **OnDialogResult** | `EventCallback<DialogResult>` | Invoked to return the dialog result. |

#### Methods
*   **`CloseAsync()` / `CloseAsync(DialogResult result)`**: Closes the dialog.
*   **`CancelAsync()`**: Closes the dialog with a cancel result.
*   **`Hide()` / `Show()`**: Controls the visibility of the dialog.

### DialogParameters<TData> Class

#### Properties
| Property | Type | Default | Description |
|---|---|---|---|
| **Title** | `string?` | | The title of the dialog. |
| **PrimaryAction** | `string?` | `OK` | The text for the primary action button. |
| **SecondaryAction** | `string?` | `Cancel` | The text for the secondary action button. |
| **Width** | `string?` | | The width of the dialog (e.g., '600px'). |
| **Height** | `string?` | | The height of the dialog (e.g., '600px'). |
| **Modal** | `bool?` | `True` | Determines if the dialog is modal. |
| **PreventDismissOnOverlayClick** | `bool` | `False` | Prevents dismissal by clicking the overlay. |
| **Content** | `TContent` | | The content to pass to and from the dialog. |

#### EventCallbacks
| EventCallback | Type | Description |
|---|---|---|
| **OnDialogResult** | `EventCallback<DialogResult>` | Callback function for the result. |
| **OnDialogClosing** | `EventCallback<DialogInstance>` | Called and awaited before the dialog fully closes. |
| **OnDialogOpened** | `EventCallback<DialogInstance>` | Called and awaited after the dialog renders for the first time. |

### DialogHelper Class
This class provides a type-safe way to show dialogs.

#### Methods
*   **`From<TDialog>()`**: Creates a dialog helper for the specified dialog type.
*   **`ShowDialogAsync<TDialog, TData>(...)`**: Shows a dialog with a specific component type as the body.