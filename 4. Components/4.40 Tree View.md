# FluentTreeView Component Documentation

## Overview

As defined by the W3C:

> A tree view widget presents a hierarchical list. Any item in the hierarchy may have child items, and items that have children may be expanded or collapsed to show or hide the children. For example, in a file system navigator that uses a tree view to display folders and files, an item representing a folder can be expanded to reveal the contents of the folder, which may be files, folders, or both.

`<FluentTreeView>` wraps the `<fluent-tree-view>` element, a web component implementation of a tree view leveraging the Fluent UI design system. It uses the `<FluentTreeItem>` component to define the nodes.

## Important Usage Notes

**NOTE**: When constructing a tree by specifying `FluentTreeItem` components, an item cannot be deselected by setting the `SelectedItem` parameter value to null. This only works when using the `Items` collection.

When using a TreeView with dynamic items, always use the `Items` collection to define the tree structure. The `FluentTreeItem` component should only be used to define the tree nodes when the tree structure is static.

## Examples

### Default with Event Handling

```razor
<FluentTreeView @bind-CurrentSelected=currentSelected OnExpandedChange="HandleOnExpandedChanged">
    <FluentTreeItem Text="Root item 1">
        <FluentTreeItem Text="Flowers">
            <FluentTreeItem Disabled="true" Text="Daisy" />
            <FluentTreeItem Text="Sunflower" />
            <FluentTreeItem Text="Rose" />
        </FluentTreeItem>
        <FluentTreeItem Text="Nested item 2" />
        <FluentTreeItem Text="Nested item 3" />
    </FluentTreeItem>
    <FluentTreeItem Text="Root item 2">
        <FluentDivider></FluentDivider>
        <FluentTreeItem Text="Flowers">
            <FluentTreeItem Disabled="true" Text="Daisy" />
            <FluentTreeItem Text="Sunflower" />
            <FluentTreeItem Text="Rose" />
        </FluentTreeItem>
        <FluentTreeItem Text="Nested item 2" />
        <FluentTreeItem Text="Nested item 3" />
    </FluentTreeItem>
    <FluentTreeItem Text="Root item 3 - Leaf Erikson" />
</FluentTreeView>

<p>Current selected tree item is @currentSelected?.Text</p>
<p>Most recently expanded/collapsed tree item is @currentAffected?.Text</p>

@code {
    FluentTreeItem? currentSelected;
    FluentTreeItem? currentAffected;

    private void HandleOnExpandedChanged(FluentTreeItem item)
    {
        currentAffected = item;
    }
}
```

### Dynamic Tree Generation via Items

```razor
<FluentTreeView Items="@Items" @bind-SelectedItem="@SelectedItem" LazyLoadItems="true">
    <ItemTemplate>
        @context.Text
        <span style="color: var(--accent-fill-rest); margin: 0 4px;">
            @(context.Items == null ? "" : $"[{context.Items.Count()}]")
        </span>
    </ItemTemplate>
</FluentTreeView>

<div>
    <b>Total items:</b> @Count
</div>
<div>
    <b>Selected item:</b> @SelectedItem?.Text
</div>

@code
{
    private ITreeViewItem? SelectedItem;

    private Icon IconCollapsed = new Icons.Regular.Size20.Folder();
    private Icon IconExpanded = new Icons.Regular.Size20.FolderOpen();

    private int Count = -1;
    private IEnumerable<ITreeViewItem>? Items = new List<ITreeViewItem>();

    protected override void OnInitialized()
    {
        Items = CreateTree(maxLevel: 5, maxItemsPerLevel: 12).Items;
        SelectedItem = Items?.ElementAt(3);
    }

    // Recursive method to create tree
    private TreeViewItem CreateTree(int maxLevel, int maxItemsPerLevel, int level = 0)
    {
        Count++;

        int nbItems = Random.Shared.Next(maxItemsPerLevel - 3, maxItemsPerLevel);

        var treeItem = new TreeViewItem
            {
                Text = $"Item {Count}",
                Disabled = level >= 2 && Count % 7 == 0,
                IconCollapsed = IconCollapsed,
                IconExpanded = IconExpanded,
                Expanded = level >= 2 && Count % 5 == 0,
                Items = level == maxLevel
                              ? null
                              : new List<TreeViewItem>(Enumerable.Range(1, nbItems)
                                                                 .Select(i => CreateTree(maxLevel, maxItemsPerLevel, level + 1))),
            };

        return treeItem;
    }
}
```

### Multi-Select

```razor
<FluentTreeView Items="@Items" LazyLoadItems="true" Class="no-selected-indicator">
    <ItemTemplate>
        <FluentCheckbox Value="@(SelectedItems.Contains(context))"
                        ValueChanged="@(e => CheckboxHandler(e, context))"
                        Style="margin-right: 12px;">
            @context.Text
        </FluentCheckbox>
    </ItemTemplate>
</FluentTreeView>

<div>
    <b>Selected items:</b> @(string.Join("; ", SelectedItems.Select(i => i.Text)))
</div>

<style>
    .no-selected-indicator fluent-tree-item[selected]::part(positioning-region) {
        background-color: var(--neutral-fill-stealth-rest);
    }

    .no-selected-indicator fluent-tree-item::part(positioning-region):hover {
        background-color: var(--neutral-fill-stealth-rest);
    }

    .no-selected-indicator fluent-tree-item[selected]::after {
        display: none;
    }
</style>

@code
{
    private int Count = -1;
    private IEnumerable<ITreeViewItem> Items = new List<ITreeViewItem>();
    private List<ITreeViewItem> SelectedItems = new List<ITreeViewItem>();

    protected override void OnInitialized()
    {
        Items = CreateTree(maxLevel: 3, nbItemsPerLevel: 5).Items ?? [];
    }

    // Add or remove item from the selected items list
    private void CheckboxHandler(bool selected, ITreeViewItem item)
    {
        if (selected && !SelectedItems.Contains(item))
        {
            SelectedItems.Add(item);
        }
        else if (!selected && SelectedItems.Contains(item))
        {
            SelectedItems.Remove(item);
        }
    }

    // Recursive method to create tree
    private TreeViewItem CreateTree(int maxLevel, int nbItemsPerLevel, int level = 0)
    {
        Count++;

        var treeItem = new TreeViewItem
            {
                Text = $"Item {Count}",
                Items = level == maxLevel
                              ? null
                              : new List<TreeViewItem>(Enumerable.Range(1, nbItemsPerLevel)
                                                                 .Select(i => CreateTree(maxLevel, nbItemsPerLevel, level + 1))),
            };

        return treeItem;
    }
}
```

### With Unlimited Items (Lazy Loading)

```razor
<FluentTreeView Items="@Items" @bind-SelectedItem="@SelectedItem" />

<div>
    Selected Item: @SelectedItem?.Text
</div>

@code
{
    private ITreeViewItem? SelectedItem;
    private IEnumerable<ITreeViewItem>? Items = new List<ITreeViewItem>();

    protected override void OnInitialized()
    {
        Items = GetItems();
    }

    private Task OnExpandedAsync(TreeViewItemExpandedEventArgs e)
    {
        if (e.Expanded)
        {
            e.CurrentItem.Items = GetItems();
        }
        else
        {
            // Remove sub-items and add a "Fake" item to simulate the [+]
            e.CurrentItem.Items = TreeViewItem.LoadingTreeViewItems;
        }

        return Task.CompletedTask;
    }

    private IEnumerable<ITreeViewItem> GetItems()
    {
        var nbItems = Random.Shared.Next(3, 9);

        return Enumerable.Range(1, nbItems).Select(i => new TreeViewItem()
            {
                Text = $"Item {Random.Shared.Next(1, 9999)}",
                OnExpandedAsync = OnExpandedAsync,
                Items = TreeViewItem.LoadingTreeViewItems, // "Fake" sub-item to simulate the [+]
            }).ToArray();
    }
}
```

### Flat Tree

```razor
<FluentTreeView>
    <FluentTreeItem InitiallySelected="true">Daisy</FluentTreeItem>
    <FluentTreeItem>Sunflower</FluentTreeItem>
    <FluentTreeItem>Rose</FluentTreeItem>
    <FluentDivider></FluentDivider>
    <FluentTreeItem>Petunia</FluentTreeItem>
    <FluentTreeItem>Tulip</FluentTreeItem>
</FluentTreeView>
```

### Some Expanded

```razor
<FluentTreeView>
    <FluentTreeItem InitiallyExpanded="true">
        Root item
        <FluentTreeItem InitiallyExpanded="true">
            Flowers
            <FluentTreeItem>Daisy</FluentTreeItem>
            <FluentTreeItem>Sunflower</FluentTreeItem>
            <FluentTreeItem>Rose</FluentTreeItem>
        </FluentTreeItem>
        <FluentTreeItem>
            Planes
            <FluentTreeItem>Tomcat</FluentTreeItem>
            <FluentTreeItem>Hawker Harrier</FluentTreeItem>
            <FluentTreeItem>Cesna</FluentTreeItem>
        </FluentTreeItem>
    </FluentTreeItem>
</FluentTreeView>
```

### Pre-selected Tree Item

```razor
<FluentTreeView>
    <FluentTreeItem InitiallyExpanded="true">
        Root item
        <FluentTreeItem>
            Flowers
            <FluentTreeItem>Daisy</FluentTreeItem>
            <FluentTreeItem>Sunflower</FluentTreeItem>
            <FluentTreeItem>Rose</FluentTreeItem>
        </FluentTreeItem>
        <FluentTreeItem InitiallyExpanded="true">
            Planes
            <FluentTreeItem InitiallySelected="true">Tomcat</FluentTreeItem>
            <FluentTreeItem>Hawker Harrier</FluentTreeItem>
            <FluentTreeItem>Cesna</FluentTreeItem>
        </FluentTreeItem>
    </FluentTreeItem>
</FluentTreeView>
```

### Disabled Tree Item

```razor
<FluentTreeView>
    <FluentTreeItem InitiallyExpanded="true">
        Root item
        <FluentTreeItem InitiallyExpanded="true">
            Flowers
            <FluentTreeItem>Daisy</FluentTreeItem>
            <FluentTreeItem>Sunflower</FluentTreeItem>
            <FluentTreeItem>Rose</FluentTreeItem>
        </FluentTreeItem>
        <FluentTreeItem InitiallyExpanded="true">
            Planes
            <FluentTreeItem Disabled="true">Tomcat</FluentTreeItem>
            <FluentTreeItem>Hawker Harrier</FluentTreeItem>
            <FluentTreeItem>Cesna</FluentTreeItem>
        </FluentTreeItem>
    </FluentTreeItem>
</FluentTreeView>
```

### With Several Nested Items (Expanded)

```razor
<FluentTreeView>
    <FluentTreeItem InitiallyExpanded="true">
        Root item
        <FluentIcon Value="@(new Icons.Regular.Size16.Globe())" Color="@Color.Neutral" Slot="start" />
        <FluentTreeItem InitiallyExpanded="true">
            Nested Root item 1
            <FluentIcon Value="@(new Icons.Regular.Size16.Globe())" Color="@Color.Neutral" Slot="start" />
            <FluentTreeItem>
                <FluentIcon Value="@(new Icons.Regular.Size16.Globe())" Color="@Color.Neutral" Slot="start" />
                Nested item 4
            </FluentTreeItem>
            <FluentTreeItem>
                Nested item 5
            </FluentTreeItem>
        </FluentTreeItem>
        <FluentTreeItem>
            Nested item 2
        </FluentTreeItem>
        <FluentTreeItem>
            Nested item 3
            <FluentIcon Value="@(new Icons.Regular.Size16.Globe())" Color="@Color.Neutral" Slot="start" />
        </FluentTreeItem>
    </FluentTreeItem>
</FluentTreeView>
```

### With Data Binding

```razor
<FluentStack Orientation="@Orientation.Horizontal">
    <FluentTreeView>
        <FluentTreeItem @bind-Expanded=@FlowersExpanded>
            Flowers
            <FluentTreeItem @bind-Selected=DaisySelected>Daisy</FluentTreeItem>
            <FluentTreeItem @bind-Selected=SunflowerSelected>Sunflower</FluentTreeItem>
            <FluentTreeItem @bind-Selected=RoseSelected>Rose</FluentTreeItem>
        </FluentTreeItem>
        <FluentTreeItem @bind-Expanded=@PlanesExpanded>
            Planes
            <FluentTreeItem>Tomcat</FluentTreeItem>
            <FluentTreeItem>Hawker Harrier</FluentTreeItem>
            <FluentTreeItem>Cesna</FluentTreeItem>
        </FluentTreeItem>
    </FluentTreeView>
    <FluentStack Orientation="@Orientation.Vertical">
        <h2>Expanded</h2>
        <FluentCheckbox @bind-Value=FlowersExpanded>
            <span aria-label="Flowers expanded">Flowers expanded</span>
        </FluentCheckbox>
        <FluentCheckbox @bind-Value=PlanesExpanded>
            <span aria-label="Planes expanded">Planes expanded</span>
        </FluentCheckbox>
    </FluentStack>
    <FluentStack Orientation="@Orientation.Vertical">
        <h2>Selected</h2>
        <FluentCheckbox @bind-Value=DaisySelected Disabled="true">
            <span aria-label="Daisy selected">Daisy selected</span>
        </FluentCheckbox>
        <FluentCheckbox @bind-Value=SunflowerSelected Disabled="true">
            <span aria-label="Sunflower selected">Sunflower selected</span>
        </FluentCheckbox>
        <FluentCheckbox @bind-Value=RoseSelected Disabled="true">
            <span aria-label="Rose selected">Rose selected</span>
        </FluentCheckbox>
    </FluentStack>
</FluentStack>

@code
{
    bool FlowersExpanded = true;
    bool PlanesExpanded = true;

    bool DaisySelected = false;
    bool SunflowerSelected = false;
    bool RoseSelected = false;
}
```

## API Documentation

### FluentTreeView Class

#### Parameters

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| `ChildContent` | `RenderFragment?` | - | Gets or sets the content to be rendered inside the component. |
| `CurrentSelected` | `FluentTreeItem?` | - | Gets or sets the currently selected tree item |
| `Items` | `IEnumerable<ITreeViewItem>?` | - | Gets or sets the list of items to bind to the tree. |
| `ItemTemplate` | `RenderFragment<ITreeViewItem>?` | - | Gets or sets the template for rendering tree items. |
| `LazyLoadItems` | `bool` | `false` | Can only be used when the `FluentTreeView.Items` is defined. Gets or sets whether the tree should use lazy loading when expanding nodes. If True, the tree will only render the children of a node when it is expanded and will remove them when it is collapsed. |
| `RenderCollapsedNodes` | `bool` | `false` | Gets or sets whether the tree should render nodes under collapsed items. Defaults to false |
| `SelectedItem` | `ITreeViewItem?` | - | Gets or sets the currently selected tree item. Only when using the `FluentTreeView.Items` property. |

#### Event Callbacks

| Event | Type | Description |
|-------|------|-------------|
| `CurrentSelectedChanged` | `EventCallback<FluentTreeItem>` | Called when `FluentTreeView.CurrentSelected` changes. You cannot update `FluentTreeItem` properties. |
| `OnExpandedChange` | `EventCallback<FluentTreeItem>` | Called whenever `FluentTreeItem.Expanded` changes on an item within the tree. You cannot update `FluentTreeItem` properties. |
| `OnSelectedChange` | `EventCallback<FluentTreeItem>` | Called whenever `FluentTreeItem.Selected` changes on an item within the tree. You cannot update `FluentTreeItem` properties. |
| `SelectedItemChanged` | `EventCallback<ITreeViewItem>` | Called when `FluentTreeView.SelectedItem` changes. Only when using the `FluentTreeView.Items` property. |

### FluentTreeItem Class

#### Parameters

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| `ChildContent` | `RenderFragment?` | - | Gets or sets the content to be rendered inside the component. |
| `Collapsed` | `bool` | `true` | Returns true if the tree item is collapsed, and false if expanded. |
| `Disabled` | `bool` | `false` | When true, the control will be immutable by user interaction. See disabled HTML attribute for more information. |
| `Expanded` | `bool` | `false` | Returns true if the tree item is expanded, and false if collapsed. |
| `IconCollapsed` | `Icon?` | - | Gets or sets the Icon displayed at the start of tree item, when the node is collapsed. If this icon is not set, the `FluentTreeItem.IconExpanded` will be used. |
| `IconExpanded` | `Icon?` | - | Gets or sets the Icon displayed at the start of tree item, when the node is expanded. If this icon is not set, the `FluentTreeItem.IconCollapsed` will be used. |
| `InitiallyExpanded` | `bool` | `false` | If set to true then the tree item will be expanded when it is created. |
| `InitiallySelected` | `bool` | `false` | If set to true then the tree item will be selected when it is created. |
| `Items` | `IEnumerable<ITreeViewItem>?` | - | Gets or sets the list of sub-items to bind to the tree item |
| `Selected` | `bool` | `false` | When true, the control will appear selected by user interaction. |
| `Text` | `string?` | - | Gets or sets the text of the tree item |

#### Event Callbacks

| Event | Type | Description |
|-------|------|-------------|
| `ExpandedChanged` | `EventCallback<bool>` | Called whenever `FluentTreeItem.Expanded` changes. |
| `SelectedChanged` | `EventCallback<bool>` | Called whenever `FluentTreeItem.Selected` changes. |

## Usage Patterns

### Static Tree Structure
Use `FluentTreeItem` components directly when your tree structure is known at compile time and doesn't change:

```razor
<FluentTreeView>
    <FluentTreeItem Text="Static Item 1">
        <FluentTreeItem Text="Child 1" />
        <FluentTreeItem Text="Child 2" />
    </FluentTreeItem>
</FluentTreeView>
```

### Dynamic Tree Structure  
Use the `Items` collection with `ITreeViewItem` when your tree structure is dynamic:

```razor
<FluentTreeView Items="@DynamicItems" @bind-SelectedItem="@SelectedItem">
    <ItemTemplate>
        @context.Text
    </ItemTemplate>
</FluentTreeView>
```

### Lazy Loading
For large datasets, use lazy loading to improve performance:

```razor
<FluentTreeView Items="@Items" LazyLoadItems="true" />
```

### Multi-Selection
Implement custom multi-selection using checkboxes:

```razor
<FluentTreeView Items="@Items" Class="no-selected-indicator">
    <ItemTemplate>
        <FluentCheckbox Value="@IsSelected(context)" 
                        ValueChanged="@(e => ToggleSelection(e, context))">
            @context.Text
        </FluentCheckbox>
    </ItemTemplate>
</FluentTreeView>
```

## Best Practices

1. **Choose the Right Approach**: Use `Items` collection for dynamic trees, `FluentTreeItem` components for static trees
2. **Performance**: Enable lazy loading for large datasets with `LazyLoadItems="true"`
3. **Icons**: Use different icons for expanded and collapsed states to improve user experience
4. **Accessibility**: Ensure proper labeling and keyboard navigation support
5. **Selection Management**: Remember that deselection with null only works with the `Items` collection approach

## Notes

- **Version**: 4.12.1+dc098671
- **Powered by**: .NET 9.0.6
- **Copyright**: Â© 2025, Baaij & Voituron, All rights reserved.

## Key Features

- **Hierarchical Display**: Support for unlimited nesting levels
- **Dynamic Content**: Data binding with `ITreeViewItem` interface
- **Lazy Loading**: Performance optimization for large datasets
- **Selection Management**: Single and multi-selection support
- **Custom Templates**: Flexible item rendering with templates
- **Icon Support**: Custom icons for expanded/collapsed states
- **Event Handling**: Rich event model for user interactions
- **Data Binding**: Two-way binding for expanded and selected states
- **Disabled Items**: Support for non-interactive items
- **Initial States**: Configure initial expanded/selected states
- **Accessibility**: Full keyboard navigation and screen reader support
- **Theming**: Consistent with Fluent UI design system